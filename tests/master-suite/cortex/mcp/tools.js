/**
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘                                                                               â•‘
 * â•‘     â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—                        â•‘
 * â•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•                        â•‘
 * â•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—                        â•‘
 * â•‘     â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â•  â•šâ•â•â•â•â–ˆâ–ˆâ•‘                        â•‘
 * â•‘      â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘                        â•‘
 * â•‘       â•šâ•â•â•â•   â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•â•šâ•â•     â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•                        â•‘
 * â•‘                                                                               â•‘
 * â•‘      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—                        â•‘
 * â•‘     â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•                        â•‘
 * â•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â•šâ–ˆâ–ˆâ–ˆâ•”â•                         â•‘
 * â•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â•   â–ˆâ–ˆâ•”â–ˆâ–ˆâ•—                         â•‘
 * â•‘     â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•—                        â•‘
 * â•‘      â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•   â•šâ•â•   â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•                        â•‘
 * â•‘                                                                               â•‘
 * â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
 * â•‘   MCP TOOLS                                                                   â•‘
 * â•‘   Executable Actions for LLM Integration                                      â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * Tools are actions the LLM can invoke to interact with Vulpes Cortex.
 *
 * TOOL CATEGORIES:
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * ANALYSIS     - Analyze patterns, metrics, codebase
 * DECISION     - Get recommendations, consult history
 * EXPERIMENT   - Run experiments, compare results
 * MANAGEMENT   - Record interventions, track changes
 * REPORTING    - Generate reports, summaries
 */

// ============================================================================
// TOOL DEFINITIONS
// ============================================================================

const { spawn } = require("child_process");
const path = require("path");

// Import async API-based test execution
const { runTestsViaAPI } = require("./tools-api-integration");
// Import API auto-start for status checks
const {
  checkApiHealth,
  ensureApiRunning,
  API_PORT,
} = require("../core/api-autostart");
const fs = require("fs");
const TOOLS = [
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // ANALYSIS PROTOCOL TOOLS - MUST USE BEFORE FIXING
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    name: "check_analysis_protocol",
    description: `MANDATORY: Call this BEFORE making any fixes. Returns:
- Known issues from SESSION_ISSUES.md
- Reminder of the analysis protocol
- Whether deep analysis is required based on failure count

This tool enforces the pattern-vs-pipeline investigation requirement.`,
    inputSchema: {
      type: "object",
      properties: {
        failureCount: {
          type: "number",
          description:
            "Number of test failures (triggers deep analysis if > 50)",
        },
        phiType: {
          type: "string",
          description: "PHI type being investigated (NAME, DATE, etc.)",
        },
      },
    },
  },
  {
    name: "log_session_issue",
    description: `Log a structural issue discovered during work. Issues are saved to docs/SESSION_ISSUES.md for future sessions.

Use this when you notice:
- Architectural problems
- Technical debt
- Hardcoded values that should be config
- Pipeline complexity issues
- Duplicate logic across filters`,
    inputSchema: {
      type: "object",
      properties: {
        issue: {
          type: "string",
          description: "Brief description of the issue",
        },
        type: {
          type: "string",
          enum: ["Architectural", "Pattern", "Config", "Performance", "Other"],
          description: "Category of issue",
        },
        files: {
          type: "string",
          description: "Affected file(s)",
        },
        severity: {
          type: "string",
          enum: ["Critical", "High", "Medium", "Low"],
          description: "Issue severity",
        },
        notes: {
          type: "string",
          description: "Additional context or recommendations",
        },
      },
      required: ["issue", "type", "severity"],
    },
  },
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // TEST EXECUTION - THE MAIN TOOL
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    name: "run_tests",
    description: `Execute the full PHI detection test suite and return comprehensive analyzed results. This is the PRIMARY tool for the improvement loop.

Returns:
- metrics: sensitivity, specificity, F1, F2, MCC, grade
- top_failure: type, count, examples, file to edit, historical context
- action: specific instruction for what to fix
- all_failures: grouped by type with counts
- insights: warnings and opportunities
- history_consulted: what worked/failed before for similar issues

After receiving results, the LLM should:
1. Read the recommended file
2. Make the fix
3. Call run_tests again to verify improvement`,
    inputSchema: {
      type: "object",
      properties: {
        profile: {
          type: "string",
          enum: ["HIPAA_STRICT", "DEVELOPMENT", "RESEARCH", "OCR_TOLERANT"],
          description: "Grading profile (default: HIPAA_STRICT)",
        },
        documentCount: {
          type: "number",
          description: "Number of test documents (default: 200)",
        },
        quick: {
          type: "boolean",
          description: "Quick test with 50 documents",
        },
        focusPhiType: {
          type: "string",
          description:
            "Focus analysis on specific PHI type (NAME, SSN, DATE, etc.)",
        },
      },
    },
  },

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // ANALYSIS TOOLS
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    name: "analyze_test_results",
    description:
      "Analyze test results to identify patterns, calculate metrics, and generate insights. Returns comprehensive analysis including failure patterns, success rates, and recommendations.",
    inputSchema: {
      type: "object",
      properties: {
        results: {
          type: "object",
          description:
            "Test results object containing documents, metrics, or raw counts (TP, FP, TN, FN)",
        },
        options: {
          type: "object",
          properties: {
            generateInsights: {
              type: "boolean",
              description: "Whether to generate insights from results",
            },
            analyzePatterns: {
              type: "boolean",
              description: "Whether to analyze failure patterns",
            },
            recordToHistory: {
              type: "boolean",
              description: "Whether to record this run to history",
            },
          },
        },
      },
      required: ["results"],
    },
  },
  {
    name: "get_codebase_state",
    description:
      "Get the current state of the PHI detection codebase including filters, dictionaries, capabilities, and gaps.",
    inputSchema: {
      type: "object",
      properties: {
        detailed: {
          type: "boolean",
          description: "Include detailed filter/dictionary information",
        },
      },
    },
  },
  {
    name: "analyze_patterns",
    description:
      "Get analysis of recurring failure and success patterns. Useful for understanding what types of PHI are being missed and why.",
    inputSchema: {
      type: "object",
      properties: {
        phiType: {
          type: "string",
          description:
            "Filter patterns by specific PHI type (e.g., NAME, SSN, DATE)",
        },
        limit: {
          type: "number",
          description: "Maximum number of patterns to return",
        },
      },
    },
  },
  {
    name: "get_metrics_trend",
    description:
      "Get the trend of a specific metric over time (improving, declining, stable).",
    inputSchema: {
      type: "object",
      properties: {
        metric: {
          type: "string",
          enum: ["sensitivity", "specificity", "f1Score", "mcc", "precision"],
          description: "Which metric to analyze",
        },
        days: { type: "number", description: "Number of days to analyze" },
      },
      required: ["metric"],
    },
  },

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // DECISION TOOLS
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    name: "get_recommendation",
    description:
      "Get comprehensive data to make a recommendation. Returns history, patterns, insights, and trends. YOU (the LLM) analyze this data and make the actual recommendation - the tool provides context, not decisions.",
    inputSchema: {
      type: "object",
      properties: {
        type: {
          type: "string",
          enum: [
            "WHAT_TO_IMPROVE",
            "HOW_TO_FIX",
            "SHOULD_WE_TRY",
            "VALIDATE_HYPOTHESIS",
            "INTERPRET_RESULTS",
          ],
          description: "Type of analysis context needed",
        },
        context: {
          type: "object",
          description:
            "Context for the recommendation (phiType, issueType, etc.)",
        },
      },
      required: ["type"],
    },
  },
  {
    name: "consult_history",
    description:
      "MANDATORY: Consult historical data before making any change. Returns what was tried before and what happened.",
    inputSchema: {
      type: "object",
      properties: {
        query: { type: "string", description: "What are you planning to try?" },
        phiType: {
          type: "string",
          description: "PHI type involved (if applicable)",
        },
        interventionType: {
          type: "string",
          description: "Type of intervention being considered",
        },
      },
      required: ["query"],
    },
  },
  {
    name: "get_active_insights",
    description:
      "Get current actionable insights including warnings, opportunities, and recommendations.",
    inputSchema: {
      type: "object",
      properties: {
        priority: {
          type: "string",
          enum: ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO", "ALL"],
          description: "Filter by priority level",
        },
        type: {
          type: "string",
          enum: ["OPPORTUNITY", "WARNING", "RECOMMENDATION", "SUCCESS", "ALL"],
          description: "Filter by insight type",
        },
      },
    },
  },

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // EXPERIMENT TOOLS
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    name: "create_experiment",
    description:
      "Create a new A/B experiment to test a change before committing it.",
    inputSchema: {
      type: "object",
      properties: {
        name: { type: "string", description: "Name of the experiment" },
        description: {
          type: "string",
          description: "What change is being tested",
        },
        hypothesisId: {
          type: "string",
          description: "ID of hypothesis being tested (if any)",
        },
        rollbackOnRegression: {
          type: "boolean",
          description: "Auto-rollback if regression detected",
        },
      },
      required: ["name", "description"],
    },
  },
  {
    name: "compare_results",
    description:
      "Compare two test results (before/after) to determine if a change improved or regressed performance.",
    inputSchema: {
      type: "object",
      properties: {
        before: { type: "object", description: "Results before the change" },
        after: { type: "object", description: "Results after the change" },
      },
      required: ["before", "after"],
    },
  },
  {
    name: "create_backup",
    description:
      "Create a backup before making changes (required for safe experimentation).",
    inputSchema: {
      type: "object",
      properties: {
        files: {
          type: "array",
          items: { type: "string" },
          description: "Files to backup",
        },
        description: {
          type: "string",
          description: "Why this backup is being created",
        },
      },
      required: ["description"],
    },
  },
  {
    name: "rollback",
    description: "Rollback to a previous backup if changes caused regression.",
    inputSchema: {
      type: "object",
      properties: {
        backupId: { type: "string", description: "ID of backup to restore" },
        reason: { type: "string", description: "Reason for rollback" },
      },
      required: ["backupId", "reason"],
    },
  },

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // MANAGEMENT TOOLS
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    name: "record_intervention",
    description:
      "Record an intervention (change) being made. Required for tracking what was tried.",
    inputSchema: {
      type: "object",
      properties: {
        type: {
          type: "string",
          enum: [
            "FILTER_MODIFICATION",
            "DICTIONARY_UPDATE",
            "PATTERN_ADDITION",
            "CONFIG_CHANGE",
            "THRESHOLD_ADJUSTMENT",
            "FEATURE_TOGGLE",
          ],
          description: "Type of intervention",
        },
        description: { type: "string", description: "What is being changed" },
        target: {
          type: "object",
          properties: {
            file: { type: "string" },
            component: { type: "string" },
            parameter: { type: "string" },
          },
        },
        metricsBefore: {
          type: "object",
          description: "Metrics before the change",
        },
        reason: {
          type: "string",
          description: "Why this change is being made",
        },
      },
      required: ["type", "description"],
    },
  },
  {
    name: "record_effect",
    description: "Record the effect of an intervention after testing.",
    inputSchema: {
      type: "object",
      properties: {
        interventionId: {
          type: "string",
          description: "ID of the intervention",
        },
        metricsAfter: {
          type: "object",
          description: "Metrics after the change",
        },
      },
      required: ["interventionId", "metricsAfter"],
    },
  },
  {
    name: "create_hypothesis",
    description: "Create a hypothesis for an improvement that can be tested.",
    inputSchema: {
      type: "object",
      properties: {
        type: {
          type: "string",
          enum: [
            "ADD_PATTERN",
            "ADD_DICTIONARY_ENTRY",
            "ENABLE_FUZZY_DICTIONARY",
            "ADJUST_THRESHOLD",
            "ADD_CONTEXT_RULE",
            "ADD_OCR_SUBSTITUTION",
          ],
          description: "Type of hypothesis",
        },
        params: {
          type: "object",
          description: "Parameters for the hypothesis (varies by type)",
        },
        evidence: {
          type: "object",
          description: "Supporting evidence (patterns, metrics)",
        },
      },
      required: ["type", "params"],
    },
  },

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // REPORTING TOOLS
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    name: "generate_report",
    description: "Generate a comprehensive report.",
    inputSchema: {
      type: "object",
      properties: {
        type: {
          type: "string",
          enum: [
            "INSIGHTS",
            "RECOMMENDATIONS",
            "CODEBASE_STATE",
            "COMPARISON",
            "FULL",
          ],
          description: "Type of report to generate",
        },
        format: {
          type: "string",
          enum: ["TEXT", "JSON"],
          description: "Output format",
        },
      },
      required: ["type"],
    },
  },
  {
    name: "get_summary",
    description:
      "Get a quick summary of current system state, suitable for context.",
    inputSchema: {
      type: "object",
      properties: {},
    },
  },

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // DIAGNOSTIC TOOLS
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    name: "diagnose",
    description: `Run diagnostics on the MCP server and test infrastructure.

Returns:
- server_status: health check information
- module_status: which Cortex modules are loaded
- recent_errors: last 10 errors with timestamps and stack traces
- environment: Node version, paths, memory usage
- recommendations: suggested fixes for any issues found

Use this when experiencing issues or before starting a testing session.`,
    inputSchema: {
      type: "object",
      properties: {
        verbose: {
          type: "boolean",
          description: "Include full stack traces and detailed module info",
        },
      },
    },
  },
];

// ============================================================================
// TOOL EXECUTION
// ============================================================================

async function executeTool(name, args, modules) {
  switch (name) {
    // ANALYSIS PROTOCOL TOOLS - MUST USE BEFORE FIXING
    case "check_analysis_protocol":
      return checkAnalysisProtocol(args, modules);

    case "log_session_issue":
      return logSessionIssue(args, modules);

    // TEST EXECUTION - PRIMARY TOOL
    case "run_tests":
      return runTests(args, modules);

    // ANALYSIS TOOLS
    case "analyze_test_results":
      return analyzeTestResults(args, modules);

    case "get_codebase_state":
      return getCodebaseState(args, modules);

    case "analyze_patterns":
      return analyzePatterns(args, modules);

    case "get_metrics_trend":
      return getMetricsTrend(args, modules);

    // DECISION TOOLS
    case "get_recommendation":
      return getRecommendation(args, modules);

    case "consult_history":
      return consultHistory(args, modules);

    case "get_active_insights":
      return getActiveInsights(args, modules);

    // EXPERIMENT TOOLS
    case "create_experiment":
      return createExperiment(args, modules);

    case "compare_results":
      return compareResults(args, modules);

    case "create_backup":
      return createBackup(args, modules);

    case "rollback":
      return rollback(args, modules);

    // MANAGEMENT TOOLS
    case "record_intervention":
      return recordIntervention(args, modules);

    case "record_effect":
      return recordEffect(args, modules);

    case "create_hypothesis":
      return createHypothesis(args, modules);

    // REPORTING TOOLS
    case "generate_report":
      return generateReport(args, modules);

    case "get_summary":
      return getSummary(modules);

    // DIAGNOSTIC TOOLS
    case "diagnose":
      return runDiagnostics(args, modules);

    default:
      throw new Error(
        `Unknown tool: ${name}. Available tools: ${TOOLS.map((t) => t.name).join(", ")}`,
      );
  }
}

// ============================================================================
// TOOL IMPLEMENTATIONS
// ============================================================================

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// run_tests - THE PRIMARY TOOL
// Executes tests and returns fully analyzed, actionable results
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function runTests(args, modules) {
  // Use async API-based execution instead of synchronous blocking
  console.error("[Cortex MCP] Using async API-based test execution");
  return await runTestsViaAPI(args, modules);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ANALYSIS PROTOCOL TOOLS
// These tools enforce the deep analysis methodology
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function checkAnalysisProtocol(args, modules) {
  const { failureCount = 0, phiType } = args || {};
  const projectRoot = path.resolve(__dirname, "../../../../");
  const sessionIssuesPath = path.join(projectRoot, "docs", "SESSION_ISSUES.md");

  const result = {
    timestamp: new Date().toISOString(),
    requiresDeepAnalysis: failureCount > 50,
    protocol: {
      phase1_research: [
        "DO NOT immediately start fixing patterns",
        "First, investigate the STRUCTURAL causes",
        "Use extended thinking for complex analysis",
        "Check if this is a PATTERN problem or PIPELINE problem",
      ],
      phase2_investigate: [
        "Run: npm run build && npm test",
        "Analyze failure distribution by PHI type",
        "Check for cascading failures from shared code",
        "Look for systemic issues, not just individual patterns",
      ],
      phase3_document: [
        "Log any structural issues discovered to SESSION_ISSUES.md",
        "Note architectural problems for future sessions",
        "Track hardcoded values that should be config",
      ],
    },
    knownIssues: [],
    reminder: null,
  };

  // Read known issues from SESSION_ISSUES.md
  try {
    if (fs.existsSync(sessionIssuesPath)) {
      const content = fs.readFileSync(sessionIssuesPath, "utf8");
      // Parse critical and high severity issues
      const criticalMatch = content.match(
        /## Critical Issues\s*([\s\S]*?)(?=##|$)/,
      );
      const highMatch = content.match(/## High Priority\s*([\s\S]*?)(?=##|$)/);

      if (criticalMatch) {
        const criticalIssues = criticalMatch[1]
          .match(/### [^\n]+/g)
          ?.map((h) => h.replace("### ", "").trim());
        if (criticalIssues)
          result.knownIssues.push(
            ...criticalIssues.map((i) => ({ severity: "CRITICAL", issue: i })),
          );
      }
      if (highMatch) {
        const highIssues = highMatch[1]
          .match(/### [^\n]+/g)
          ?.map((h) => h.replace("### ", "").trim());
        if (highIssues)
          result.knownIssues.push(
            ...highIssues.map((i) => ({ severity: "HIGH", issue: i })),
          );
      }
    }
  } catch (e) {
    result.knownIssues.push({
      severity: "INFO",
      issue: "Could not read SESSION_ISSUES.md: " + e.message,
    });
  }

  // Add specific reminder based on context
  if (failureCount > 50) {
    result.reminder = `
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  âš ï¸  DEEP ANALYSIS REQUIRED - ${failureCount} FAILURES DETECTED
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  STOP! Before making any fixes:                                              â•‘
â•‘  1. Investigate WHY these failures are occurring                             â•‘
â•‘  2. Check if this is a PATTERN problem or PIPELINE problem                   â•‘
â•‘  3. Look for structural/architectural issues                                 â•‘
â•‘  4. Document findings in docs/SESSION_ISSUES.md                              â•‘
â•‘  5. Use extended thinking for complex root cause analysis                    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`;
  } else if (phiType) {
    result.reminder = `
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ“‹  ANALYSIS PROTOCOL for ${phiType}
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Before editing any ${phiType} filter:
â”‚  1. Check if spans are being detected (pattern issue)                        â”‚
â”‚  2. Check if spans are being filtered out downstream (pipeline issue)        â”‚
â”‚  3. Review PostFilterService for hardcoded exclusions                        â”‚
â”‚  4. Document any structural issues found                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜`;
  }

  return result;
}

async function logSessionIssue(args, modules) {
  const { issue, type, files, severity, notes } = args;

  if (!issue || !type || !severity) {
    throw new Error("Required fields: issue, type, severity");
  }

  const projectRoot = path.resolve(__dirname, "../../../../");
  const sessionIssuesPath = path.join(projectRoot, "docs", "SESSION_ISSUES.md");

  // Create docs directory if it doesn't exist
  const docsDir = path.dirname(sessionIssuesPath);
  if (!fs.existsSync(docsDir)) {
    fs.mkdirSync(docsDir, { recursive: true });
  }

  // Read existing content or create new
  let content = "";
  if (fs.existsSync(sessionIssuesPath)) {
    content = fs.readFileSync(sessionIssuesPath, "utf8");
  } else {
    content = `# Session Issues Tracker

This file tracks structural and architectural issues discovered during sessions.
Issues are logged automatically via the \`log_session_issue\` MCP tool.

## Critical Issues

## High Priority

## Medium Priority

## Low Priority

## Resolved Issues

---
`;
  }

  // Determine which section to add to based on severity
  const sectionMap = {
    Critical: "## Critical Issues",
    High: "## High Priority",
    Medium: "## Medium Priority",
    Low: "## Low Priority",
  };

  const sectionHeader = sectionMap[severity] || "## Medium Priority";
  const issueId = `${type.charAt(0)}${Date.now().toString(36).slice(-4).toUpperCase()}`;

  const newEntry = `
### ${issueId}: ${issue}
- **Type**: ${type}
- **Severity**: ${severity}
- **Files**: ${files || "Not specified"}
- **Logged**: ${new Date().toISOString().split("T")[0]}
${notes ? `- **Notes**: ${notes}` : ""}
`;

  // Insert the new issue after the section header
  const sectionIndex = content.indexOf(sectionHeader);
  if (sectionIndex !== -1) {
    const insertPoint = sectionIndex + sectionHeader.length;
    content =
      content.slice(0, insertPoint) + newEntry + content.slice(insertPoint);
  } else {
    // Section not found, add at end
    content += "\n" + sectionHeader + newEntry;
  }

  // Write back
  fs.writeFileSync(sessionIssuesPath, content, "utf8");

  return {
    success: true,
    issueId,
    message: `Issue logged as ${issueId} in docs/SESSION_ISSUES.md`,
    severity,
    location: sessionIssuesPath,
  };
}

async function analyzeTestResults(args, modules) {
  const { results, options = {} } = args;

  const analysis = {
    timestamp: new Date().toISOString(),
    metrics: null,
    patterns: null,
    insights: null,
  };

  // Calculate metrics
  if (modules.metricsEngine) {
    analysis.metrics = modules.metricsEngine.calculateAll(results);
  }

  // Analyze patterns
  if (options.analyzePatterns !== false && modules.patternRecognizer) {
    analysis.patterns = modules.patternRecognizer.analyzeTestResult(results);
  }

  // Generate insights
  if (options.generateInsights && modules.insightGenerator) {
    analysis.insights = modules.insightGenerator.generateInsights();
  }

  // Record to history
  if (options.recordToHistory && modules.temporalIndex) {
    modules.temporalIndex.recordMetrics(analysis.metrics);
  }

  return analysis;
}

async function getCodebaseState(args, modules) {
  const { detailed = false } = args;

  if (modules.codebaseStateTracker) {
    return detailed
      ? modules.codebaseStateTracker.getCurrentState()
      : modules.codebaseStateTracker.exportForLLM();
  }

  if (modules.codebaseAnalyzer) {
    return detailed
      ? modules.codebaseAnalyzer.takeSnapshot()
      : modules.codebaseAnalyzer.exportForLLM();
  }

  throw new Error("No codebase analyzer available");
}

async function analyzePatterns(args, modules) {
  const { phiType, limit = 10 } = args;

  if (!modules.patternRecognizer) {
    throw new Error("Pattern recognizer not available");
  }

  if (phiType) {
    return modules.patternRecognizer.getPatternsByPhiType(phiType);
  }

  return {
    topFailures: modules.patternRecognizer.getTopFailurePatterns(limit),
    trending: modules.patternRecognizer.getTrendingPatterns(),
    stats: modules.patternRecognizer.getStats(),
  };
}

async function getMetricsTrend(args, modules) {
  const { metric, days = 30 } = args;

  if (!modules.temporalIndex) {
    throw new Error("Temporal index not available");
  }

  return modules.temporalIndex.analyzeTrend(metric, { days });
}

async function getRecommendation(args, modules) {
  const { type, context = {} } = args;

  // IMPORTANT: This tool gathers DATA for the LLM to analyze.
  // The LLM makes the actual recommendation based on this data.
  // We do NOT make decisions here - we provide context.

  const data = {
    requestType: type,
    context,
    timestamp: new Date().toISOString(),

    // Historical data - what was tried before?
    history: null,

    // Current state - what does the codebase look like?
    codebaseState: null,

    // Patterns - what's failing and why?
    patterns: null,

    // Insights - what has the system learned?
    insights: null,

    // Metrics trends - are things improving or declining?
    trends: null,
  };

  // Gather history
  if (modules.historyConsultant) {
    data.history = await modules.historyConsultant.consult(type, context);
  }

  // Gather codebase state
  if (modules.codebaseAnalyzer) {
    data.codebaseState = modules.codebaseAnalyzer.exportForLLM();
  }

  // Gather patterns
  if (modules.patternRecognizer) {
    data.patterns = {
      topFailures: modules.patternRecognizer.getTopFailurePatterns(10),
      byPhiType: context.phiType
        ? modules.patternRecognizer.getPatternsByPhiType(context.phiType)
        : null,
      stats: modules.patternRecognizer.getStats(),
    };
  }

  // Gather insights
  if (modules.insightGenerator) {
    const allInsights = modules.insightGenerator.getActiveInsights();
    data.insights = {
      critical: allInsights.filter((i) => i.priority === "CRITICAL"),
      high: allInsights.filter((i) => i.priority === "HIGH"),
      medium: allInsights.filter((i) => i.priority === "MEDIUM").slice(0, 5),
      total: allInsights.length,
    };
  }

  // Gather trends
  if (modules.temporalIndex) {
    data.trends = {
      sensitivity: modules.temporalIndex.analyzeTrend("sensitivity"),
      specificity: modules.temporalIndex.analyzeTrend("specificity"),
      mcc: modules.temporalIndex.analyzeTrend("mcc"),
    };
  }

  // Add guidance for LLM on what to consider
  data.analysisGuidance = getAnalysisGuidance(type);

  return data;
}

function getAnalysisGuidance(type) {
  const guidance = {
    WHAT_TO_IMPROVE: {
      task: "Determine what area needs the most attention",
      consider: [
        "Critical and high-priority insights first",
        "Patterns with highest failure counts",
        "Trends showing decline",
        "Historical success/failure rates for similar interventions",
      ],
      output: "Prioritized list of improvement areas with reasoning",
    },
    HOW_TO_FIX: {
      task: "Develop a specific fix strategy",
      consider: [
        "What worked before for similar issues (history)",
        "What failed before and why",
        "Current codebase capabilities",
        "Risk of regression",
      ],
      output: "Step-by-step fix plan with risk assessment",
    },
    SHOULD_WE_TRY: {
      task: "Decide whether to proceed with a proposed change",
      consider: [
        "Historical success rate for similar changes",
        "Current system stability (trends)",
        "Potential impact vs risk",
        "Whether proper testing is possible",
      ],
      output: "GO/NO-GO decision with clear reasoning",
    },
    VALIDATE_HYPOTHESIS: {
      task: "Assess if a hypothesis is worth testing",
      consider: [
        "Evidence supporting the hypothesis",
        "Similar hypotheses tested before",
        "Cost of testing vs potential benefit",
        "Current priorities",
      ],
      output: "Validation assessment with confidence level",
    },
    INTERPRET_RESULTS: {
      task: "Explain what test results mean",
      consider: [
        "Comparison to previous runs (trends)",
        "Statistical significance",
        "Which PHI types improved/regressed",
        "Whether changes achieved their goal",
      ],
      output: "Clear interpretation with next steps",
    },
  };

  return (
    guidance[type] || {
      task: "Analyze the provided data and make a recommendation",
      consider: ["All available context"],
      output: "Reasoned recommendation",
    }
  );
}

async function consultHistory(args, modules) {
  const { query, phiType, interventionType } = args;

  if (!modules.historyConsultant) {
    throw new Error("History consultant not available");
  }

  return await modules.historyConsultant.consult(
    interventionType || "GENERAL",
    {
      description: query,
      phiType,
      type: interventionType,
    },
  );
}

async function getActiveInsights(args, modules) {
  const { priority = "ALL", type = "ALL" } = args;

  if (!modules.insightGenerator) {
    throw new Error("Insight generator not available");
  }

  let insights = modules.insightGenerator.getActiveInsights();

  if (priority !== "ALL") {
    insights = insights.filter((i) => i.priority === priority);
  }

  if (type !== "ALL") {
    insights = insights.filter((i) => i.type === type);
  }

  return {
    count: insights.length,
    insights: insights.slice(0, 20),
    summary: modules.insightGenerator.getSummary(),
  };
}

async function createExperiment(args, modules) {
  const { name, description, hypothesisId, rollbackOnRegression = true } = args;

  if (!modules.experimentRunner) {
    throw new Error("Experiment runner not available");
  }

  return modules.experimentRunner.createExperiment({
    name,
    treatment: { description },
    hypothesisId,
    rollbackOnRegression,
  });
}

async function compareResults(args, modules) {
  const { before, after } = args;

  if (!modules.comparisonEngine) {
    throw new Error("Comparison engine not available");
  }

  return modules.comparisonEngine.compare(before, after);
}

async function createBackup(args, modules) {
  const { files = [], description } = args;

  if (!modules.rollbackManager) {
    throw new Error("Rollback manager not available");
  }

  return modules.rollbackManager.createBackup({
    files,
    description,
  });
}

async function rollback(args, modules) {
  const { backupId, reason } = args;

  if (!modules.rollbackManager) {
    throw new Error("Rollback manager not available");
  }

  return modules.rollbackManager.executeRollback(backupId, { reason });
}

async function recordIntervention(args, modules) {
  const { type, description, target, metricsBefore, reason } = args;

  if (!modules.interventionTracker) {
    throw new Error("Intervention tracker not available");
  }

  return modules.interventionTracker.recordIntervention({
    type,
    description,
    target,
    metricsBefore,
    reason,
    triggeredBy: "llm",
  });
}

async function recordEffect(args, modules) {
  const { interventionId, metricsAfter } = args;

  if (!modules.interventionTracker) {
    throw new Error("Intervention tracker not available");
  }

  return modules.interventionTracker.recordEffect(interventionId, metricsAfter);
}

async function createHypothesis(args, modules) {
  const { type, params, evidence = {} } = args;

  if (!modules.hypothesisEngine) {
    throw new Error("Hypothesis engine not available");
  }

  return modules.hypothesisEngine.createHypothesis(type, params, evidence);
}

async function generateReport(args, modules) {
  const { type, format = "TEXT" } = args;

  let report;

  switch (type) {
    case "INSIGHTS":
      report = modules.insightGenerator?.generateReport();
      break;
    case "RECOMMENDATIONS":
      report = modules.recommendationBuilder?.generateReport();
      break;
    case "CODEBASE_STATE":
      report = modules.codebaseStateTracker?.generateReport();
      break;
    case "COMPARISON":
      const recent = modules.comparisonEngine?.getRecentComparisons(1);
      report = recent?.[0]
        ? modules.comparisonEngine.generateReport(recent[0].id)
        : "No recent comparisons";
      break;
    case "FULL":
      report = generateFullReport(modules);
      break;
    default:
      throw new Error(`Unknown report type: ${type}`);
  }

  if (format === "JSON") {
    return { report, format: "JSON" };
  }

  return report || "Report generation failed";
}

function generateFullReport(modules) {
  return `
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  VULPES CORTEX - FULL STATUS REPORT                                          â•‘
â•‘  Generated: ${new Date().toISOString()}
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

${modules.codebaseStateTracker?.generateReport() || "Codebase state unavailable"}

${modules.insightGenerator?.generateReport() || "Insights unavailable"}

${modules.recommendationBuilder?.generateReport() || "Recommendations unavailable"}
`;
}

async function getSummary(modules) {
  return {
    timestamp: new Date().toISOString(),
    codebase: modules.codebaseStateTracker?.exportForLLM() || null,
    patterns: modules.patternRecognizer?.exportForLLM() || null,
    insights: modules.insightGenerator?.getSummary() || null,
    interventions: modules.interventionTracker?.getStats() || null,
    experiments: modules.experimentRunner?.getStats() || null,
    decisions: modules.decisionEngine?.exportForLLM() || null,
  };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// runDiagnostics - Comprehensive server diagnostics
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function runDiagnostics(args, modules) {
  const { verbose = false } = args || {};
  const diagnostics = {
    timestamp: new Date().toISOString(),
    status: "OK",
    issues: [],
    recommendations: [],
  };

  // 0. API Server Status (with auto-start capability)
  console.error("[Cortex MCP] Checking API server status...");
  const apiHealth = await checkApiHealth();
  diagnostics.apiServer = {
    port: API_PORT,
    running: apiHealth.running,
    autoStartEnabled: true,
    status: apiHealth.running
      ? "âœ“ running"
      : "âœ— not running (will auto-start when needed)",
  };
  if (apiHealth.status) {
    diagnostics.apiServer.uptime = apiHealth.status.uptime;
    diagnostics.apiServer.database = apiHealth.status.database;
  }

  // 1. Server Status
  diagnostics.server = {
    uptime: process.uptime(),
    pid: process.pid,
    nodeVersion: process.version,
    platform: process.platform,
    arch: process.arch,
    memoryUsage: {
      heapUsed:
        Math.round(process.memoryUsage().heapUsed / 1024 / 1024) + " MB",
      heapTotal:
        Math.round(process.memoryUsage().heapTotal / 1024 / 1024) + " MB",
      rss: Math.round(process.memoryUsage().rss / 1024 / 1024) + " MB",
    },
  };

  // 2. Module Status
  diagnostics.modules = {};
  const expectedModules = [
    "knowledgeBase",
    "metricsEngine",
    "codebaseAnalyzer",
    "temporalIndex",
    "patternRecognizer",
    "hypothesisEngine",
    "interventionTracker",
    "insightGenerator",
    "experimentRunner",
    "snapshotManager",
    "comparisonEngine",
    "rollbackManager",
    "decisionEngine",
    "historyConsultant",
    "recommendationBuilder",
    "codebaseStateTracker",
  ];

  let loadedCount = 0;
  for (const moduleName of expectedModules) {
    const isLoaded = modules[moduleName] != null;
    diagnostics.modules[moduleName] = isLoaded ? "âœ“ loaded" : "âœ— NOT LOADED";
    if (isLoaded) loadedCount++;
    if (!isLoaded) {
      diagnostics.issues.push(`Module "${moduleName}" is not loaded`);
    }
  }
  diagnostics.modulesSummary = `${loadedCount}/${expectedModules.length} modules loaded`;

  // 3. Test Infrastructure Check
  diagnostics.testInfrastructure = {};
  try {
    const fs = require("fs");
    const assessmentPath = require.resolve("../../assessment/assessment");
    diagnostics.testInfrastructure.rigorousAssessment = fs.existsSync(
      assessmentPath,
    )
      ? "âœ“ available"
      : "âœ— NOT FOUND";
  } catch (e) {
    diagnostics.testInfrastructure.rigorousAssessment = `âœ— ERROR: ${e.message}`;
    diagnostics.issues.push(
      "RigorousAssessment module not found - tests will fail",
    );
  }

  try {
    const enginePath = require.resolve("../../../../dist/VulpesCelare.js");
    diagnostics.testInfrastructure.vulpesCelareEngine = "âœ“ built";
  } catch (e) {
    diagnostics.testInfrastructure.vulpesCelareEngine = "âœ— NOT BUILT";
    diagnostics.issues.push(
      "VulpesCelare engine not built - run 'npm run build' first",
    );
    diagnostics.recommendations.push("Run: npm run build");
  }

  // 4. Environment Variables
  diagnostics.environment = {
    VULPES_DEBUG: process.env.VULPES_DEBUG || "not set",
    NODE_ENV: process.env.NODE_ENV || "not set",
    cwd: process.cwd(),
  };

  // 5. Generate Recommendations
  if (diagnostics.issues.length === 0) {
    diagnostics.recommendations.push(
      "All systems operational - ready for testing",
    );
  } else {
    diagnostics.status = "ISSUES_FOUND";
    diagnostics.recommendations.unshift(
      `Found ${diagnostics.issues.length} issue(s) that should be addressed`,
    );
  }

  // Verbose mode adds more detail
  if (verbose) {
    diagnostics.detailedModuleInfo = {};
    for (const [name, module] of Object.entries(modules)) {
      if (module && typeof module.exportForLLM === "function") {
        try {
          diagnostics.detailedModuleInfo[name] = module.exportForLLM();
        } catch (e) {
          diagnostics.detailedModuleInfo[name] = { error: e.message };
        }
      }
    }
  }

  return diagnostics;
}

// ============================================================================
// EXPORTS
// ============================================================================

function getTools() {
  return TOOLS;
}

module.exports = {
  getTools,
  executeTool,
};
